<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程</title>
      <link href="/2021/08/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/08/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程是系统运行程序的最小单位，线程是程序执行的最小单位。</p><p>一个main方法有五个进程：</p><ul><li>添加时间进程 Attach Listener</li><li>分发处理给jvm信号的进程 Signal Dispatcher</li><li>调用方法的进程 Finalizer</li><li>清除线程  Reserence Handler</li><li>main线程 程序入口</li></ul><h2 id="进程与线程的区别："><a href="#进程与线程的区别：" class="headerlink" title="进程与线程的区别："></a>进程与线程的区别：</h2><ul><li>一个进程可以有多个线程，线程共享进程的堆和方法区（堆存储创建的所有对象，方法区存储加载的类信息、常量等）</li><li>进程之间互相独立，进程则不一定</li><li>每个线程有自己独立的栈（虚拟机栈和本地方法栈）和程序计数器<ul><li>程序计数器私有是为了线程切换后能够回到之前执行的位置</li><li>栈私有是为了保证线程中的局部变量不被其他线程访问</li></ul></li><li>线程执行开销小，不容易以资源管理和保护，进程相反</li></ul><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ol><li>并发：同一时间段，多个任务都在执行</li><li>并行：单位时间内，多个任务同时执行</li></ol><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><ol><li>NEW  新建状态（没有调用start方法）</li><li>RUNNABLE 运行状态（新建线程后执行start方法，进入就绪状态，分配到cpu资源后进入运行状态，因为就绪状态时间很短，所以java不区分，统称运行状态）</li><li>BLOCKED 阻塞状态 （线程没有获取到锁的时候进入到阻塞状态）</li><li>WAITING  等待状态（进入等待状态需要其他线程的通知才能恢复到运行状态）</li><li>TIME_WAITING 超时等待状态（线程执行sleep（long millis)或者wait(long millis)方法，进入超时等待状态，时间到了后恢复到运行状态）</li><li>TERMINATED 终止状态（线程执行完RUNNABLE内的run方法后，进入到终止状态）</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>多个线程同时被阻塞，都在等待某一个资源被释放</p><h4 id="死锁必备四个条件："><a href="#死锁必备四个条件：" class="headerlink" title="死锁必备四个条件："></a>死锁必备四个条件：</h4><ul><li>互斥条件：该资源任意时刻只能被一个线程持有</li><li>请求与保持条件：一个进程因为请求资源而阻塞时，不释放已持有的资源</li><li>不剥夺条件：线程已获得的资源不能被其他线程剥夺，只能自己使用完毕后释放</li><li>循环等待条件：多个线程之间行成头尾相接的循环等待资源关系</li></ul><h4 id="避免死锁和破坏死锁"><a href="#避免死锁和破坏死锁" class="headerlink" title="避免死锁和破坏死锁"></a>避免死锁和破坏死锁</h4><ol><li>避免死锁：<ul><li>资源分配时借助算法对资源分配进行评估</li></ul></li><li>破坏死锁：<ul><li>破坏请求与保持条件：一次性申请所有资源</li><li>破坏不剥夺条件：占用资源的进程进一步申请资源申请不到时，主动释放已获取的资源</li><li>破坏循环等待条件：按照顺序申请资源，释放资源则反序释放</li></ul></li></ol><h2 id="sleep-方法和wait-方法的区别和共同点"><a href="#sleep-方法和wait-方法的区别和共同点" class="headerlink" title="sleep()方法和wait()方法的区别和共同点"></a>sleep()方法和wait()方法的区别和共同点</h2><ul><li>区别：sleep方法不会释放锁，wait方法释放锁</li><li>相同：都会暂停线程执行<ul><li>wait常用与线程之间通信，sleep常用户暂停执行</li><li>wait执行后不会自动苏醒，需要其他线程调用同一对象的notify方法或者notifyall方法。sleep方法执行完成后，会自动唤醒，或者可以使用wait（long timeout）超时后线程自动苏醒</li></ul></li></ul><h2 id="为什么调用start方法时会执行run方法，而不能直接执行run方法"><a href="#为什么调用start方法时会执行run方法，而不能直接执行run方法" class="headerlink" title="为什么调用start方法时会执行run方法，而不能直接执行run方法"></a>为什么调用start方法时会执行run方法，而不能直接执行run方法</h2><ul><li>新建一个线程后，调用start方法，线程进入就绪状态之后分配到cpu资源后就可以开始运行，start会执行线程的准备工作，然后自动执行run方法的内容，这是真正的多线程工作。而直接运行run方法，main线程会将run方法当成普通方法执行，不是多线程工作。</li></ul><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ol><li>继承thread类<ul><li>优点：代码简单</li><li>缺点：无法集成别的类</li></ul></li><li>实现RUNNABLE接口<ul><li>优点：可以继承其他类，同一实现该接口的实例可以共享资源</li><li>缺点：代码复杂</li></ul></li><li>实现Callable接口<ul><li>优点：可以获得异步任务的返回值</li></ul></li><li>线程池方式<ul><li>优点：自动化装配，易于管理，循环利用资源</li></ul></li></ol><h2 id="创建线程池的几种方式"><a href="#创建线程池的几种方式" class="headerlink" title="创建线程池的几种方式"></a>创建线程池的几种方式</h2><ol><li>使用Executor工厂创建<ul><li>newFixedThreadPool  创建一个固定长度的线程池，每提交一个任务就创建一个线程，当线程数达到最大数量，超出的会在队列中等待</li><li>newCacheThreadPool 创建一个可缓存的线程池，规模不受限制，当规模超出了任务数量自动回收，增加任务会自动添加线程</li><li>newSingleThreadPool 创建一个单线程化的线程池，它只会使用唯一的工作的线程来处理任务，保证所有任务根据指定顺序（FIFO，LIFO，优先级执行）</li><li>newScheduledThreadPool 创建一个固定长度的线程池，支持定时和周期性执行任务</li></ul></li></ol><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>悲观锁：认为操作数据时，其他人也会同事修改数据，因此操作时直接将数据锁住，操作完成后再释放，上锁旗舰其他人会阻塞。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现</li><li>乐观锁：操作数据时认为别人不会修改数据，不会上锁，当操作完成执行更新时才会检查是否有人修改了数据，如果有人修改则放弃操作，否则执行更新</li></ol><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li><p>乐观锁</p><ul><li><p>CAS方式（Compare And Swap）：CAS包含三个操作数，1️⃣需要读写的内存位置（V）2️⃣进行比较的预期值（A）3️⃣拟写入的新值（B）</p><p>操作逻辑：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。</p><p>CAS包含比较和交换两个操作，如何保证原子性：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">在下面的代码示例中：value1没有进行任何线程安全方面的保护，value2使用了乐观锁(CAS)，value3使用了悲观锁(<span class="keyword">synchronized</span>)。运行程序，使用<span class="number">1000</span>个线程同时对value1、value2和value3进行自增操作，可以发现：value2和value3的值总是等于<span class="number">1000</span>，而value1的值常常小于<span class="number">1000</span>。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//value1：线程不安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value1 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//value2：使用乐观锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger value2 = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//value3：使用悲观锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value3 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increaseValue3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value3++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//开启1000个线程，并执行自增操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    value1++;</span><br><span class="line">                    value2.getAndIncrement();</span><br><span class="line">                    increaseValue3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;线程不安全：&quot;</span> + value1);</span><br><span class="line">        System.out.println(<span class="string">&quot;乐观锁(AtomicInteger)：&quot;</span> + value2);</span><br><span class="line">        System.out.println(<span class="string">&quot;悲观锁(synchronized)：&quot;</span> + value3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>版本号方式：在数据库中新增一个字段version表示该数据的版本号，每当数据修改时，版本号+1，当某个线程查询数据时，将该数据的版本号一起查出来，当更新该数据时，判断当前版本号是否和之前读取的版本号一致，如果一致才进行操作。</p><p>假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><p>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。<br>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。<br>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。<br>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 当前最后更新的version与操作员第一次的版本号相等 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。<br>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>乐观锁主要用在读多写少的场景，即冲很少的时候，可以省去锁的开销</li><li>悲观锁主要用多写的场景</li></ul><h4 id="乐观锁加锁吗？"><a href="#乐观锁加锁吗？" class="headerlink" title="乐观锁加锁吗？"></a>乐观锁加锁吗？</h4><p>​    乐观锁不加锁，只是在更新时判断一下数据是否被更新了，如AtomicInteger</p><p>​    乐观锁可以和加锁操作结合，比如在sql中使用for update加锁，但是不能改变乐观锁不加锁的事实</p></li></ul><h4 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h4><ul><li><p>ABA问题：</p><p>假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作：</p><p>(1)线程1读取内存中数据为A；</p><p>(2)线程2将该数据修改为B；</p><p>(3)线程2将该数据修改为A；</p><p>(4)线程1对数据进行CAS操作</p><p>在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。</p><p>在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。</p><p>对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。Java中的AtomicStampedReference类便是使用版本号来解决ABA问题的。</p></li><li><p>高竞争下的开销问题</p><p>在高并发情况加，如果CAS一直失败，会不断进行重试，cpu开销大，这种情况可以引入退出机制，即当重试次数超过一定阈值后失败退出。最好的办法是在高竞争条件下避免使用乐观锁</p></li><li><p>CAS功能限制</p><p>涉及到多个变量，CAS无法处理</p><p>CAS依赖硬件层面，用户不能直接调用，只能依赖java下的atomic下的原子类使用，灵活性受到限制</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
